*** linux-2.4.10-stock/net/ipv4/netfilter/Config.in	Wed Mar  7 01:44:16 2001
--- linux-2.4.10-vnat/net/ipv4/netfilter/Config.in	Wed Oct  3 16:36:20 2001
***************
*** 41,46 ****
--- 41,47 ----
      dep_tristate '  Full NAT' CONFIG_IP_NF_NAT $CONFIG_IP_NF_IPTABLES $CONFIG_IP_NF_CONNTRACK
      if [ "$CONFIG_IP_NF_NAT" != "n" ]; then
        define_bool CONFIG_IP_NF_NAT_NEEDED y
+       bool '    NAT of local connections' CONFIG_IP_NF_NAT_LOCAL
        dep_tristate '    MASQUERADE target support' CONFIG_IP_NF_TARGET_MASQUERADE $CONFIG_IP_NF_NAT
        dep_tristate '    REDIRECT target support' CONFIG_IP_NF_TARGET_REDIRECT $CONFIG_IP_NF_NAT
        # If they want FTP, set to $CONFIG_IP_NF_NAT (m or y), 
*** linux-2.4.10-stock/net/ipv4/netfilter/ip_nat_core.c	Wed May 16 13:31:27 2001
--- linux-2.4.10-vnat/net/ipv4/netfilter/ip_nat_core.c	Wed Oct  3 16:36:20 2001
***************
*** 314,319 ****
--- 314,320 ----
  			 * do_extra_mangle last time. */
  			*other_ipp = saved_ip;
  
+ #ifdef CONFIG_IP_NF_NAT_LOCAL
  			if (hooknum == NF_IP_LOCAL_OUT
  			    && *var_ipp != orig_dstip
  			    && !do_extra_mangle(*var_ipp, other_ipp)) {
***************
*** 324,329 ****
--- 325,331 ----
  				 * anyway. */
  				continue;
  			}
+ #endif
  
  			/* Count how many others map onto this. */
  			score = count_maps(tuple->src.ip, tuple->dst.ip,
***************
*** 449,455 ****
                                     may be able to play with ports to
                                     make it unique. */
  				struct ip_nat_range r
! 					= { IP_NAT_RANGE_MAP_IPS, 
  					    tuple->src.ip, tuple->src.ip,
  					    { 0 }, { 0 } };
  				DEBUGP("Trying implicit mapping\n");
--- 451,457 ----
                                     may be able to play with ports to
                                     make it unique. */
  				struct ip_nat_range r
! 					= { IP_NAT_RANGE_MAP_IPS,
  					    tuple->src.ip, tuple->src.ip,
  					    { 0 }, { 0 } };
  				DEBUGP("Trying implicit mapping\n");
***************
*** 494,500 ****
  static unsigned int opposite_hook[NF_IP_NUMHOOKS]
  = { [NF_IP_PRE_ROUTING] = NF_IP_POST_ROUTING,
      [NF_IP_POST_ROUTING] = NF_IP_PRE_ROUTING,
!     [NF_IP_LOCAL_OUT] = NF_IP_POST_ROUTING
  };
  
  unsigned int
--- 496,505 ----
  static unsigned int opposite_hook[NF_IP_NUMHOOKS]
  = { [NF_IP_PRE_ROUTING] = NF_IP_POST_ROUTING,
      [NF_IP_POST_ROUTING] = NF_IP_PRE_ROUTING,
! #ifdef CONFIG_IP_NF_NAT_LOCAL
!     [NF_IP_LOCAL_OUT] = NF_IP_LOCAL_IN,
!     [NF_IP_LOCAL_IN] = NF_IP_LOCAL_OUT
! #endif
  };
  
  unsigned int
***************
*** 507,515 ****
  	struct ip_nat_info *info = &conntrack->nat.info;
  
  	MUST_BE_WRITE_LOCKED(&ip_nat_lock);
  	IP_NF_ASSERT(hooknum == NF_IP_PRE_ROUTING
  		     || hooknum == NF_IP_POST_ROUTING
! 		     || hooknum == NF_IP_LOCAL_OUT);
  	IP_NF_ASSERT(info->num_manips < IP_NAT_MAX_MANIPS);
  
  	/* What we've got will look like inverse of reply. Normally
--- 512,526 ----
  	struct ip_nat_info *info = &conntrack->nat.info;
  
  	MUST_BE_WRITE_LOCKED(&ip_nat_lock);
+ #ifdef CONFIG_IP_NF_NAT_LOCAL
  	IP_NF_ASSERT(hooknum == NF_IP_PRE_ROUTING
  		     || hooknum == NF_IP_POST_ROUTING
! 		     || hooknum == NF_IP_LOCAL_OUT
! 		     || hooknum == NF_IP_LOCAL_IN);
! #else
! 	IP_NF_ASSERT(hooknum == NF_IP_PRE_ROUTING
! 		     || hooknum == NF_IP_POST_ROUTING);
! #endif
  	IP_NF_ASSERT(info->num_manips < IP_NAT_MAX_MANIPS);
  
  	/* What we've got will look like inverse of reply. Normally
*** linux-2.4.10-stock/net/ipv4/netfilter/ip_nat_rule.c	Fri Apr 27 17:15:01 2001
--- linux-2.4.10-vnat/net/ipv4/netfilter/ip_nat_rule.c	Wed Oct  3 16:36:20 2001
***************
*** 27,33 ****
  #define DEBUGP(format, args...)
  #endif
  
! #define NAT_VALID_HOOKS ((1<<NF_IP_PRE_ROUTING) | (1<<NF_IP_POST_ROUTING) | (1<<NF_IP_LOCAL_OUT))
  
  /* Standard entry. */
  struct ipt_standard
--- 27,37 ----
  #define DEBUGP(format, args...)
  #endif
  
! #ifdef CONFIG_IP_NF_NAT_LOCAL
! #define NAT_VALID_HOOKS ((1<<NF_IP_PRE_ROUTING) | (1<<NF_IP_POST_ROUTING) | (1<<NF_IP_LOCAL_OUT) | (1<<NF_IP_LOCAL_IN))
! #else
! #define NAT_VALID_HOOKS ((1<<NF_IP_PRE_ROUTING) | (1<<NF_IP_POST_ROUTING))
! #endif
  
  /* Standard entry. */
  struct ipt_standard
***************
*** 51,67 ****
  static struct
  {
  	struct ipt_replace repl;
! 	struct ipt_standard entries[3];
  	struct ipt_error term;
  } nat_initial_table __initdata
! = { { "nat", NAT_VALID_HOOKS, 4,
!       sizeof(struct ipt_standard) * 3 + sizeof(struct ipt_error),
        { [NF_IP_PRE_ROUTING] 0,
! 	[NF_IP_POST_ROUTING] sizeof(struct ipt_standard),
! 	[NF_IP_LOCAL_OUT] sizeof(struct ipt_standard) * 2 },
        { [NF_IP_PRE_ROUTING] 0,
! 	[NF_IP_POST_ROUTING] sizeof(struct ipt_standard),
! 	[NF_IP_LOCAL_OUT] sizeof(struct ipt_standard) * 2 },
        0, NULL, { } },
      {
  	    /* PRE_ROUTING */
--- 55,91 ----
  static struct
  {
  	struct ipt_replace repl;
! #ifdef CONFIG_IP_NF_NAT_LOCAL
! 	struct ipt_standard entries[4];
! #else
! 	struct ipt_standard entries[2];
! #endif
  	struct ipt_error term;
  } nat_initial_table __initdata
! = { { "nat", NAT_VALID_HOOKS,
! #ifdef CONFIG_IP_NF_NAT_LOCAL
!       5, sizeof(struct ipt_standard) * 4 + sizeof(struct ipt_error),
! #else
!       3, sizeof(struct ipt_standard) * 2 + sizeof(struct ipt_error),
! #endif
        { [NF_IP_PRE_ROUTING] 0,
! #ifdef CONFIG_IP_NF_NAT_LOCAL
! 	[NF_IP_LOCAL_IN] sizeof(struct ipt_standard),
! 	[NF_IP_LOCAL_OUT] sizeof(struct ipt_standard) * 2,
! 	[NF_IP_POST_ROUTING] sizeof(struct ipt_standard) * 3
! #else
! 	[NF_IP_POST_ROUTING] sizeof(struct ipt_standard)
! #endif
!       },
        { [NF_IP_PRE_ROUTING] 0,
! #ifdef CONFIG_IP_NF_NAT_LOCAL
! 	[NF_IP_LOCAL_IN] sizeof(struct ipt_standard),
! 	[NF_IP_LOCAL_OUT] sizeof(struct ipt_standard) * 2,
! 	[NF_IP_POST_ROUTING] sizeof(struct ipt_standard) * 3
! #else
! 	[NF_IP_POST_ROUTING] sizeof(struct ipt_standard)
! #endif
!       },
        0, NULL, { } },
      {
  	    /* PRE_ROUTING */
***************
*** 72,78 ****
  		0, { 0, 0 }, { } },
  	      { { { { IPT_ALIGN(sizeof(struct ipt_standard_target)), "" } }, { } },
  		-NF_ACCEPT - 1 } },
! 	    /* POST_ROUTING */
  	    { { { { 0 }, { 0 }, { 0 }, { 0 }, "", "", { 0 }, { 0 }, 0, 0, 0 },
  		0,
  		sizeof(struct ipt_entry),
--- 96,103 ----
  		0, { 0, 0 }, { } },
  	      { { { { IPT_ALIGN(sizeof(struct ipt_standard_target)), "" } }, { } },
  		-NF_ACCEPT - 1 } },
! #ifdef CONFIG_IP_NF_NAT_LOCAL
! 	    /* LOCAL_IN */
  	    { { { { 0 }, { 0 }, { 0 }, { 0 }, "", "", { 0 }, { 0 }, 0, 0, 0 },
  		0,
  		sizeof(struct ipt_entry),
***************
*** 87,92 ****
--- 112,126 ----
  		sizeof(struct ipt_standard),
  		0, { 0, 0 }, { } },
  	      { { { { IPT_ALIGN(sizeof(struct ipt_standard_target)), "" } }, { } },
+ 		-NF_ACCEPT - 1 } },
+ #endif
+ 	    /* POST_ROUTING */
+ 	    { { { { 0 }, { 0 }, { 0 }, { 0 }, "", "", { 0 }, { 0 }, 0, 0, 0 },
+ 		0,
+ 		sizeof(struct ipt_entry),
+ 		sizeof(struct ipt_standard),
+ 		0, { 0, 0 }, { } },
+ 	      { { { { IPT_ALIGN(sizeof(struct ipt_standard_target)), "" } }, { } },
  		-NF_ACCEPT - 1 } }
      },
      /* ERROR */
***************
*** 119,125 ****
--- 153,164 ----
  	struct ip_conntrack *ct;
  	enum ip_conntrack_info ctinfo;
  
+ #ifdef CONFIG_IP_NF_NAT_LOCAL
+ 	IP_NF_ASSERT(hooknum == NF_IP_POST_ROUTING || hooknum == NF_IP_LOCAL_IN);
+ 
+ #else
  	IP_NF_ASSERT(hooknum == NF_IP_POST_ROUTING);
+ #endif
  
  	ct = ip_conntrack_get(*pskb, &ctinfo);
  
***************
*** 140,147 ****
  	struct ip_conntrack *ct;
  	enum ip_conntrack_info ctinfo;
  
! 	IP_NF_ASSERT(hooknum == NF_IP_PRE_ROUTING
! 		     || hooknum == NF_IP_LOCAL_OUT);
  
  	ct = ip_conntrack_get(*pskb, &ctinfo);
  
--- 179,189 ----
  	struct ip_conntrack *ct;
  	enum ip_conntrack_info ctinfo;
  
! #ifdef CONFIG_IP_NF_NAT_LOCAL
! 	IP_NF_ASSERT(hooknum == NF_IP_PRE_ROUTING || hooknum == NF_IP_LOCAL_OUT);
! #else
! 	IP_NF_ASSERT(hooknum == NF_IP_PRE_ROUTING);
! #endif
  
  	ct = ip_conntrack_get(*pskb, &ctinfo);
  
***************
*** 179,185 ****
  		return 0;
  	}
  
! 	if (hook_mask & ~(1 << NF_IP_POST_ROUTING)) {
  		DEBUGP("SNAT: hook mask 0x%x bad\n", hook_mask);
  		return 0;
  	}
--- 221,231 ----
  		return 0;
  	}
  
! 	if (hook_mask & ~((1 << NF_IP_POST_ROUTING)
! #ifdef CONFIG_IP_NF_NAT_LOCAL
! 			  | (1 << NF_IP_LOCAL_IN)
! #endif
! 	    )) {
  		DEBUGP("SNAT: hook mask 0x%x bad\n", hook_mask);
  		return 0;
  	}
***************
*** 214,220 ****
  		return 0;
  	}
  
! 	if (hook_mask & ~((1 << NF_IP_PRE_ROUTING) | (1 << NF_IP_LOCAL_OUT))) {
  		DEBUGP("DNAT: hook mask 0x%x bad\n", hook_mask);
  		return 0;
  	}
--- 260,270 ----
  		return 0;
  	}
  
! 	if (hook_mask & ~((1 << NF_IP_PRE_ROUTING)
! #ifdef CONFIG_IP_NF_NAT_LOCAL
! 			  | (1 << NF_IP_LOCAL_OUT)
! #endif
! 	    )) {
  		DEBUGP("DNAT: hook mask 0x%x bad\n", hook_mask);
  		return 0;
  	}
*** linux-2.4.10-stock/net/ipv4/netfilter/ip_nat_standalone.c	Fri Apr 27 17:15:01 2001
--- linux-2.4.10-vnat/net/ipv4/netfilter/ip_nat_standalone.c	Wed Oct  3 16:36:20 2001
***************
*** 41,47 ****
  #define HOOKNAME(hooknum) ((hooknum) == NF_IP_POST_ROUTING ? "POST_ROUTING"  \
  			   : ((hooknum) == NF_IP_PRE_ROUTING ? "PRE_ROUTING" \
  			      : ((hooknum) == NF_IP_LOCAL_OUT ? "LOCAL_OUT"  \
! 				 : "*ERROR*")))
  
  static unsigned int
  ip_nat_fn(unsigned int hooknum,
--- 41,48 ----
  #define HOOKNAME(hooknum) ((hooknum) == NF_IP_POST_ROUTING ? "POST_ROUTING"  \
  			   : ((hooknum) == NF_IP_PRE_ROUTING ? "PRE_ROUTING" \
  			      : ((hooknum) == NF_IP_LOCAL_OUT ? "LOCAL_OUT"  \
!                                  : ((hooknum) == NF_IP_LOCAL_IN ? "LOCAL_IN" \
! 				   : "*ERROR*"))))
  
  static unsigned int
  ip_nat_fn(unsigned int hooknum,
***************
*** 57,63 ****
  	enum ip_nat_manip_type maniptype = HOOK2MANIP(hooknum);
  
  	/* We never see fragments: conntrack defrags on pre-routing
! 	   and local-out, and ip_nat_out protects post-routing. */
  	IP_NF_ASSERT(!((*pskb)->nh.iph->frag_off
  		       & __constant_htons(IP_MF|IP_OFFSET)));
  
--- 58,65 ----
  	enum ip_nat_manip_type maniptype = HOOK2MANIP(hooknum);
  
  	/* We never see fragments: conntrack defrags on pre-routing
! 	   and local-out, and ip_nat_out protects post-routing and
! 	   local-in. */
  	IP_NF_ASSERT(!((*pskb)->nh.iph->frag_off
  		       & __constant_htons(IP_MF|IP_OFFSET)));
  
***************
*** 231,236 ****
--- 233,243 ----
  /* Before packet filtering, change destination */
  static struct nf_hook_ops ip_nat_local_out_ops
  = { { NULL, NULL }, ip_nat_local_fn, PF_INET, NF_IP_LOCAL_OUT, NF_IP_PRI_NAT_DST };
+ #ifdef CONFIG_IP_NF_NAT_LOCAL
+ /* After packet filtering, change source */
+ static struct nf_hook_ops ip_nat_local_in_ops
+ = { { NULL, NULL }, ip_nat_out, PF_INET, NF_IP_LOCAL_IN, NF_IP_PRI_NAT_SRC };
+ #endif
  
  /* Protocol registration. */
  int ip_nat_protocol_register(struct ip_nat_protocol *proto)
***************
*** 300,305 ****
--- 307,319 ----
  		printk("ip_nat_init: can't register local out hook.\n");
  		goto cleanup_outops;
  	}
+ #ifdef CONFIG_IP_NF_NAT_LOCAL
+ 	ret = nf_register_hook(&ip_nat_local_in_ops);
+ 	if (ret < 0) {
+ 		printk("ip_nat_init: can't register local in hook.\n");
+ 		goto cleanup_localops;
+ 	}
+ #endif
  	if (ip_conntrack_module)
  		__MOD_INC_USE_COUNT(ip_conntrack_module);
  	return ret;
***************
*** 307,312 ****
--- 321,330 ----
   cleanup:
  	if (ip_conntrack_module)
  		__MOD_DEC_USE_COUNT(ip_conntrack_module);
+ #ifdef CONFIG_IP_NF_NAT_LOCAL
+ 	nf_unregister_hook(&ip_nat_local_in_ops);
+  cleanup_localops:
+ #endif
  	nf_unregister_hook(&ip_nat_local_out_ops);
   cleanup_outops:
  	nf_unregister_hook(&ip_nat_out_ops);
*** linux-2.4.10-stock/include/linux/netfilter_ipv4/ip_nat.h	Wed Sep 26 00:24:09 2001
--- linux-2.4.10-vnat/include/linux/netfilter_ipv4/ip_nat.h	Wed Oct  3 16:36:20 2001
***************
*** 11,18 ****
  	IP_NAT_MANIP_DST
  };
  
! /* SRC manip occurs only on POST_ROUTING */
  #define HOOK2MANIP(hooknum) ((hooknum) != NF_IP_POST_ROUTING)
  
  /* 2.3.19 (I hope) will define this in linux/netfilter_ipv4.h. */
  #ifndef SO_ORIGINAL_DST
--- 11,22 ----
  	IP_NAT_MANIP_DST
  };
  
! /* SRC manip occurs only on POST_ROUTING and LOCAL_IN */
! #ifdef CONFIG_IP_NF_NAT_LOCAL
! #define HOOK2MANIP(hooknum) ((hooknum) != NF_IP_POST_ROUTING && (hooknum) != NF_IP_LOCAL_IN)
! #else
  #define HOOK2MANIP(hooknum) ((hooknum) != NF_IP_POST_ROUTING)
+ #endif
  
  /* 2.3.19 (I hope) will define this in linux/netfilter_ipv4.h. */
  #ifndef SO_ORIGINAL_DST
*** linux-2.4.10-stock/net/ipv4/netfilter/ip_conntrack_standalone.c	Fri Sep 14 17:04:08 2001
--- linux-2.4.10-vnat/net/ipv4/netfilter/ip_conntrack_standalone.c	Mon Oct 22 13:35:26 2001
***************
*** 336,338 ****
--- 336,339 ----
  EXPORT_SYMBOL(ip_conntrack_tuple_taken);
  EXPORT_SYMBOL(ip_ct_gather_frags);
  EXPORT_SYMBOL(ip_conntrack_htable_size);
+ EXPORT_SYMBOL(ip_conntrack_find_get);
*** linux-2.4.10-stock/net/netsyms.c	Tue Sep 18 16:39:51 2001
--- linux-2.4.10-vnat/net/netsyms.c	Wed Feb  6 17:42:41 2002
***************
*** 367,372 ****
--- 367,373 ----
  EXPORT_SYMBOL(tcp_tw_deschedule);
  EXPORT_SYMBOL(tcp_delete_keepalive_timer);
  EXPORT_SYMBOL(tcp_reset_keepalive_timer);
+ EXPORT_SYMBOL(sysctl_tcp_keepalive_time);
  EXPORT_SYMBOL(sysctl_local_port_range);
  EXPORT_SYMBOL(tcp_port_rover);
  EXPORT_SYMBOL(udp_port_rover);
